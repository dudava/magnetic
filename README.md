# TODO:
- Разобраться с None в json (ЧЕК!)
- Изменить способ именования пакетов (ЧЕК!)
- Изменение уже созданных экземпляров пакетами, пришедшими с хоста (ЧЕК!)
- Создание новых экземпляров из чужих пакетов (ЧЕК!)
- Инициализация объекта данными из пакета при первом получении (ЧЕК!)
- Разбиение объектов по id в client (ЧЕК!)
- При выходе клиента, удалять все созданные им объекты (ЧЕК!)
- ISynchronizedManager. Синхронизация состояния сервера.


## Отложено:
- Сглаживание пинга (Может быть реализовано, исходя из игровых механик. Пока отложено)


# Общая концепция

## Присвоение айди

Айди игрока игрока присваивается по правилу первого свободного, начиная с 0.

## Работа с обычными объектами

Экземпляр, обладаюший уникальным именем должен быть добавлен в словарь, создан и синхронизирован. Они распределяются внутри словаря по айди. 

Новый экземпляр добавляется в коде путем использования метода synchronize клиента и название класса. Его имя должно быть получено автоматически исходя из счетчика созданных объектов в классе и айди клиента. Метод должен возвращать экземпляр класса для работы с ним.

Например: "Hero-InId:0-CId:0", Hero - класс, InId - счетчик экземпляров класса, CId - айди игрока.

Если объект уже есть в словаре, его нужно просто обновить.

## Работа с множеством определенных объектов

Если нужно создавать много объектов, нужно использовать класс, наследующий от ISynchronizedManager и передавать данные для него. Он должен хранить информацию о состоянии игрового мира в данный момент и изменяться от запросов игроков. 

По идее взаимодействие большого количества объектов можно реализовать и через ISynchronizedObject. В методе getPackingData поставить условие: передавать состояние в целом не в каждом пакете, а только тогда, когда оно изменяется (объект изменен или уничтожен). Но основная проблема в том, что только зашедший игрок и этих данных не может получить полную информацию о состоянии игрового поля. 

Нужна другая концепция: на входе игрок должен получить интересующую его информацию о игровом мире (поле кирпичиков, рекорды игроков и т.д.). Эта информация очевидно хранится на стороне сервера и изменяется тоже на его стороне. То есть помимо определения классов ISynchronizedObject на стороне клиента, нужно еще опеределять классы ISynchronizedManager на стороне сервера.

У класса, наследующего от ISynchronizedManager, может быть только один экземпляр для всех игроков. Методы: получить состояние, изменить. Например: {BricksManager: {""}}


## Отключение игрока

Если клиент отключается, хост присваивает его айди значение "closed", чтоб другие могли его прочитать и удалить из своих словарей его экземляры. 


